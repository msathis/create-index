{"version":3,"sources":["../../src/utilities/writeIndexCli.js"],"names":["directoryPaths","options","sortedDirectoryPaths","updateIndex","green","red","ignoreUnsafe","recursive","map","dir","fileName","silent","flatten","uniq","reverse","join","filter","directoryPath","forEach","existingIndexCode","siblings","indexCode","banner","indexFilePath","resolve","readFileSync","error","writeFileSync","yellow"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;kBAEe,UAACA,cAAD,EAAkC;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;;AAC/C,MAAIC,oBAAJ;;AAEAA,yBAAuB,2BAAYF,cAAZ,CAAvB;;AAEA,qBAAI,oBAAJ,EAA0BE,oBAA1B;AACA,MAAID,QAAQE,WAAZ,EAAyB;AACvB,uBAAI,eAAJ,EAAqBF,QAAQE,WAAR,GAAsB,gBAAMC,KAAN,CAAY,MAAZ,CAAtB,GAA4C,gBAAMC,GAAN,CAAU,OAAV,CAAjE;AACD,GAFD,MAEO;AACL,uBAAI,YAAJ,EAAkBJ,QAAQK,YAAR,GAAuB,gBAAMF,KAAN,CAAY,MAAZ,CAAvB,GAA6C,gBAAMC,GAAN,CAAU,OAAV,CAA/D;AACA,uBAAI,gBAAJ,EAAsBJ,QAAQK,YAAR,GAAuB,gBAAMF,KAAN,CAAY,MAAZ,CAAvB,GAA6C,gBAAMC,GAAN,CAAU,OAAV,CAAnE;AACD;;AAED,MAAIJ,QAAQE,WAAR,IAAuBF,QAAQM,SAAnC,EAA8C;AAC5CL,2BAAuB,iBAAEM,GAAF,CAAMN,oBAAN,EAA6BO,GAAD,IAAS;AAC1D,aAAO,8BAAeA,GAAf,EAAoB;AACzBC,kBAAUT,QAAQE,WAAR,GAAsB,UAAtB,GAAmC,GADpB;AAEzBQ,gBAAQV,QAAQE,WAAR,IAAuBF,QAAQK;AAFd,OAApB,CAAP;AAID,KALsB,CAAvB;AAMAJ,2BAAuB,iBAAEU,OAAF,CAAUV,oBAAV,CAAvB;AACAA,2BAAuB,iBAAEW,IAAF,CAAOX,oBAAP,CAAvB;AACAA,2BAAuB,2BAAYA,oBAAZ,CAAvB;;AAEA,uBAAI,0BAAJ,EAAgCA,qBAAqBY,OAArB,GAA+BC,IAA/B,CAAoC,IAApC,CAAhC;AACD;;AAEDb,yBAAuBA,qBAAqBc,MAArB,CAA6BC,aAAD,IAAmB;AACpE,WAAO,uCAAwBA,aAAxB,EAAuC,EAACN,QAAQV,QAAQK,YAAjB,EAAvC,CAAP;AACD,GAFsB,CAAvB;;AAIA,mBAAEY,OAAF,CAAUhB,oBAAV,EAAiCe,aAAD,IAAmB;AACjD,QAAIE,iBAAJ;;AAEA,UAAMC,WAAW,6BAAcH,aAAd,EAA6B,EAACN,QAAQV,QAAQK,YAAjB,EAA7B,CAAjB;;AAEA,UAAMe,YAAY,+BAAgBD,QAAhB,EAA0B;AAC1CE,cAAQrB,QAAQqB;AAD0B,KAA1B,CAAlB;;AAIA,UAAMC,gBAAgB,eAAKC,OAAL,CAAaP,aAAb,EAA4B,UAA5B,CAAtB;;AAEA,QAAI;AACFE,0BAAoB,aAAGM,YAAH,CAAgBF,aAAhB,EAA+B,MAA/B,CAApB;;AAEE;AACH,KAJD,CAIE,OAAOG,KAAP,EAAc,CAEf;;AAEG;;AAEJ,iBAAGC,aAAH,CAAiBJ,aAAjB,EAAgCF,SAAhC;;AAEA,QAAIF,qBAAqBA,sBAAsBE,SAA/C,EAA0D;AACxD,yBAAIE,aAAJ,EAAmB,gBAAMK,MAAN,CAAa,yBAAb,CAAnB;AACD,KAFD,MAEO,IAAIT,qBAAqBA,sBAAsBE,SAA/C,EAA0D;AAC/D,yBAAIE,aAAJ,EAAmB,gBAAMnB,KAAN,CAAY,iBAAZ,CAAnB;AACD,KAFM,MAEA;AACL,yBAAImB,aAAJ,EAAmB,gBAAMnB,KAAN,CAAY,iBAAZ,CAAnB;AACD;AACF,GA9BD;;AAgCA,qBAAI,MAAJ;AACD,C","file":"writeIndexCli.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport _ from 'lodash';\nimport chalk from 'chalk';\nimport createIndexCode from './createIndexCode';\nimport validateTargetDirectory from './validateTargetDirectory';\nimport readDirectory from './readDirectory';\nimport sortByDepth from './sortByDepth';\nimport log from './log';\nimport findIndexFiles from './findIndexFiles';\n\nexport default (directoryPaths, options = {}) => {\n  let sortedDirectoryPaths;\n\n  sortedDirectoryPaths = sortByDepth(directoryPaths);\n\n  log('Target directories', sortedDirectoryPaths);\n  if (options.updateIndex) {\n    log('Update index:', options.updateIndex ? chalk.green('true') : chalk.red('false'));\n  } else {\n    log('Recursive:', options.ignoreUnsafe ? chalk.green('true') : chalk.red('false'));\n    log('Ignore unsafe:', options.ignoreUnsafe ? chalk.green('true') : chalk.red('false'));\n  }\n\n  if (options.updateIndex || options.recursive) {\n    sortedDirectoryPaths = _.map(sortedDirectoryPaths, (dir) => {\n      return findIndexFiles(dir, {\n        fileName: options.updateIndex ? 'index.js' : '*',\n        silent: options.updateIndex || options.ignoreUnsafe\n      });\n    });\n    sortedDirectoryPaths = _.flatten(sortedDirectoryPaths);\n    sortedDirectoryPaths = _.uniq(sortedDirectoryPaths);\n    sortedDirectoryPaths = sortByDepth(sortedDirectoryPaths);\n\n    log('Updating index files in:', sortedDirectoryPaths.reverse().join(', '));\n  }\n\n  sortedDirectoryPaths = sortedDirectoryPaths.filter((directoryPath) => {\n    return validateTargetDirectory(directoryPath, {silent: options.ignoreUnsafe});\n  });\n\n  _.forEach(sortedDirectoryPaths, (directoryPath) => {\n    let existingIndexCode;\n\n    const siblings = readDirectory(directoryPath, {silent: options.ignoreUnsafe});\n\n    const indexCode = createIndexCode(siblings, {\n      banner: options.banner\n    });\n\n    const indexFilePath = path.resolve(directoryPath, 'index.js');\n\n    try {\n      existingIndexCode = fs.readFileSync(indexFilePath, 'utf8');\n\n        /* eslint-disable no-empty */\n    } catch (error) {\n\n    }\n\n        /* eslint-enable no-empty */\n\n    fs.writeFileSync(indexFilePath, indexCode);\n\n    if (existingIndexCode && existingIndexCode === indexCode) {\n      log(indexFilePath, chalk.yellow('[index has not changed]'));\n    } else if (existingIndexCode && existingIndexCode !== indexCode) {\n      log(indexFilePath, chalk.green('[updated index]'));\n    } else {\n      log(indexFilePath, chalk.green('[created index]'));\n    }\n  });\n\n  log('Done');\n};\n"]}